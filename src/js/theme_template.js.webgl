(function () {
  // Grab body node
  const bodyNode = document.querySelector('body');

  let viewWidth = undefined;
  let viewHeight = undefined;
  let canvas = undefined;
  let ctx = undefined;

  // Canvas settings
  const patternSize = 64;
  const patternScaleX = 3;
  const patternScaleY = 1;
  const patternRefreshInterval = 2;
  const patternAlpha = 5; // int between 0 and 255,

  const patternPixelDataLength = patternSize * patternSize * 4;
  let patternCanvas = undefined;
  let patternCtx = undefined;
  let patternData = undefined;
  let frame = 0;

  let retroCanvas = undefined;
  let gl = undefined;
  let prog = undefined;
  let bufObj = {};
  let textureObj = undefined;
  let maskTextureObj;
  let progDraw = undefined;

  // Entrypoint, it all starts here
  const initVT220 = (obs) => {
    var themeStyleTag = document.querySelector('.vscode-tokens-styles');

    if (!themeStyleTag) {
      return;
    }

    var initialThemeStyles = themeStyleTag.innerText;
    var updatedThemeStyles = initialThemeStyles;

    // loadShaderTags();

    // Additional classes
    // bodyNode.classList.add('noise');

    // Update main container with data attribute for style targeting
    const gridView = document.querySelector('.chromium > .monaco-grid-view');
    gridView.classList.add('main-container');

    // Create canvas
    const retroCanvasTag = document.createElement('canvas');
    retroCanvasTag.setAttribute('id', 'retro-canvas');
    document.body.appendChild(retroCanvasTag);

    const canvasTag = document.createElement('canvas');
    canvasTag.setAttribute('id', 'canvas');
    canvasTag.setAttribute('width', '100%');
    canvasTag.setAttribute('height', '100%');
    document.body.appendChild(canvasTag);
    console.log(canvasTag);
    canvas = canvasTag;

    /* append the remaining styles */
    updatedThemeStyles = `${updatedThemeStyles}[CHROME_STYLES]`;

    const newStyleTag = document.createElement('style');
    newStyleTag.setAttribute('id', 'vt220-theme-styles');
    newStyleTag.innerText = updatedThemeStyles.replace(/(\r\n|\n|\r)/gm, '');
    document.body.appendChild(newStyleTag);

    console.log('VT220: initialised!');

    initCanvas();
    initGrain();
    requestAnimationFrame(loop);

    initWebGl();

    // const customPostProc = new CustomPostProcessing();
    // console.log(customPostProc);

    // disconnect the observer because we don't need it anymore
    if (obs) {
      obs.disconnect();
    }
  };

  const render = (delteMS) => {
    var vp = [retroCanvas.width, retroCanvas.height];
    var distortion = 0.12; //document.getElementById('distortion').value / 100.0;
    var rgbShift = 0; //document.getElementById('rgbshift').value / 1000.0;
    var stripes = 0; //document.getElementById('stripes').value / 100.0;

    gl.viewport(0, 0, retroCanvas.width, retroCanvas.height);
    gl.enable(gl.DEPTH_TEST);
    gl.clearColor(0.0, 0.0, 0.0, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    var texUnit = 0;
    gl.activeTexture(gl.TEXTURE0 + texUnit);
    gl.bindTexture(gl.TEXTURE_2D, textureObj);
    Use(progDraw);
    SetI1(progDraw, 'u_texture', texUnit);
    SetF1(progDraw, 'u_distortion', distortion);
    SetF1(progDraw, 'u_stripe', stripes);
    SetF1(progDraw, 'u_rgbshift', rgbShift);
    drawVertexBuffer(bufRect);

    requestAnimationFrame(render);
  };

  const resize = () => {
    vp_size = [window.innerWidth, window.innerHeight];
    //vp_size = [256, 256]
    retroCanvas.width = vp_size[0];
    retroCanvas.height = vp_size[1];
  };

  const CreateProg = (shaderList) => {
    var shaderObjs = [];
    for (var i_sh = 0; i_sh < shaderList.length; ++i_sh) {
      var shderObj = Compile(shaderList[i_sh].source, shaderList[i_sh].stage);
      if (shderObj) shaderObjs.push(shderObj);
    }

    var prog = {};
    prog.progObj = Link(shaderObjs);
    if (prog.progObj) {
      prog.attrInx = {};
      var noOfAttributes = gl.getProgramParameter(prog.progObj, gl.ACTIVE_ATTRIBUTES);
      for (var i_n = 0; i_n < noOfAttributes; ++i_n) {
        var name = gl.getActiveAttrib(prog.progObj, i_n).name;
        prog.attrInx[name] = gl.getAttribLocation(prog.progObj, name);
      }
      prog.uniLoc = {};
      var noOfUniforms = gl.getProgramParameter(prog.progObj, gl.ACTIVE_UNIFORMS);
      for (var i_n = 0; i_n < noOfUniforms; ++i_n) {
        var name = gl.getActiveUniform(prog.progObj, i_n).name;
        prog.uniLoc[name] = gl.getUniformLocation(prog.progObj, name);
      }
    }
    return prog;
  };

  const AttrI = (prog, name) => {
    return prog.attrInx[name];
  };

  const UniformL = (prog, name) => {
    return prog.uniLoc[name];
  };

  const Use = (prog) => {
    gl.useProgram(prog.progObj);
  };

  const SetI1 = (prog, name, val) => {
    if (prog.uniLoc[name]) gl.uniform1i(prog.uniLoc[name], val);
  };

  const SetF1 = (prog, name, val) => {
    if (prog.uniLoc[name]) gl.uniform1f(prog.uniLoc[name], val);
  };

  const SetF2 = (prog, name, arr) => {
    if (prog.uniLoc[name]) gl.uniform2fv(prog.uniLoc[name], arr);
  };

  const SetF3 = (prog, name, arr) => {
    if (prog.uniLoc[name]) gl.uniform3fv(prog.uniLoc[name], arr);
  };

  const SetF4 = (prog, name, arr) => {
    if (prog.uniLoc[name]) gl.uniform4fv(prog.uniLoc[name], arr);
  };

  const SetM33 = (prog, name, mat) => {
    if (prog.uniLoc[name]) gl.uniformMatrix3fv(prog.uniLoc[name], false, mat);
  };

  const SetM44 = (prog, name, mat) => {
    if (prog.uniLoc[name]) gl.uniformMatrix4fv(prog.uniLoc[name], false, mat);
  };

  const Compile = (source, shaderStage) => {
    var shaderScript = document.getElementById(source);
    if (shaderScript) {
      source = shaderScript.text;
    }
    var shaderObj = gl.createShader(shaderStage);
    gl.shaderSource(shaderObj, source);
    gl.compileShader(shaderObj);
    var status = gl.getShaderParameter(shaderObj, gl.COMPILE_STATUS);
    if (!status) {
      console.error(gl.getShaderInfoLog(shaderObj));
    }
    return status ? shaderObj : null;
  };

  const Link = (shaderObjs) => {
    var prog = gl.createProgram();

    for (var i_sh = 0; i_sh < shaderObjs.length; ++i_sh) {
      gl.attachShader(prog, shaderObjs[i_sh]);
    }

    gl.linkProgram(prog);
    status = gl.getProgramParameter(prog, gl.LINK_STATUS);

    if (!status) {
      console.error(gl.getProgramInfoLog(prog));
    }

    return status ? prog : null;
  };

  const createVertexBuffer = (attribs, indices, type) => {
    var buffer = {
      buf: [],
      attr: [],
      inx: gl.createBuffer(),
      inxLen: indices.length,
      primitive_type: type ? type : gl.TRIANGLES,
    };
    for (var i = 0; i < attribs.length; ++i) {
      buffer.buf.push(gl.createBuffer());
      buffer.attr.push({
        size: attribs[i].attrSize,
        loc: attribs[i].attrLoc,
        no_of: attribs[i].data.length / attribs[i].attrSize,
      });
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer.buf[i]);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(attribs[i].data), gl.STATIC_DRAW);
    }
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    if (buffer.inxLen > 0) {
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer.inx);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
    }
    return buffer;
  };

  const drawVertexBuffer = (bufObj) => {
    for (var i = 0; i < bufObj.buf.length; ++i) {
      gl.bindBuffer(gl.ARRAY_BUFFER, bufObj.buf[i]);
      gl.vertexAttribPointer(bufObj.attr[i].loc, bufObj.attr[i].size, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(bufObj.attr[i].loc);
    }
    if (bufObj.inxLen > 0) {
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bufObj.inx);
      gl.drawElements(bufObj.primitive_type, bufObj.inxLen, gl.UNSIGNED_SHORT, 0);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
    } else gl.drawArrays(bufObj.primitive_type, 0, bufObj.attr[0].no_of);
    for (var i = 0; i < bufObj.buf.length; ++i) gl.disableVertexAttribArray(bufObj.attr[i].loc);
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
  };

  const HandleLoadedTexture2D = (image, texture, flipY) => {
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY != undefined && flipY == true);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.bindTexture(gl.TEXTURE_2D, null);

    return texture;
  };

  const LoadTexture2D = (name) => {
    var texture = gl.createTexture();
    texture.image = new Image();
    texture.image.setAttribute('crossorigin', 'anonymous');
    texture.image.onload = function () {
      HandleLoadedTexture2D(texture.image, texture, false);
    };
    texture.image.src = name;
    return texture;
  };

  // create a canvas which will render the grain
  const initCanvas = () => {
    console.log(canvas);
    viewWidth = canvas.width = canvas.clientWidth;
    viewHeight = canvas.height = canvas.clientHeight;
    ctx = canvas.getContext('2d');

    ctx.scale(patternScaleX, patternScaleY);
  };

  // create a canvas which will be used as a pattern
  const initGrain = () => {
    patternCanvas = document.createElement('canvas');
    patternCanvas.width = patternSize;
    patternCanvas.height = patternSize;
    patternCtx = patternCanvas.getContext('2d');
    patternData = patternCtx.createImageData(patternSize, patternSize);
  };

  // put a random shade of gray into every pixel of the pattern
  const update = () => {
    var value;

    for (var i = 0; i < patternPixelDataLength; i += 4) {
      value = (Math.random() * 255) | 0;

      patternData.data[i] = value;
      patternData.data[i + 1] = value;
      patternData.data[i + 2] = value;
      patternData.data[i + 3] = patternAlpha;
    }

    patternCtx.putImageData(patternData, 0, 0);
  };

  // fill the canvas using the pattern
  const draw = () => {
    ctx.clearRect(0, 0, viewWidth, viewHeight);

    ctx.fillStyle = ctx.createPattern(patternCanvas, 'repeat');
    ctx.fillRect(0, 0, viewWidth, viewHeight);
  };

  const loop = () => {
    if (++frame % patternRefreshInterval === 0) {
      update();
      draw();
    }

    requestAnimationFrame(loop);
  };

  // Callback function to execute when mutations are observed
  const watchForBootstrap = function (mutationsList, observer) {
    for (let mutation of mutationsList) {
      if (mutation.type === 'attributes') {
        // only init if we're using a VT220 subtheme
        const isUsingVt220 = document.querySelector(
          '[class*="LeandroRodrigues-vt220-vscode-themes"]',
        );
        // does the style div exist yet?
        const tokensLoaded = document.querySelector('.vscode-tokens-styles');
        // does it have content ?
        const tokenStyles = document.querySelector('.vscode-tokens-styles').innerText;

        // sometimes VS code takes a while to init the styles content, so stop this observer and add an observer for that
        if (isUsingVt220 && tokensLoaded) {
          observer.disconnect();
          observer.observe(tokensLoaded, { childList: true });
        }
      }
      if (mutation.type === 'childList') {
        const isUsingVt220 = document.querySelector(
          '[class*="LeandroRodrigues-vt220-vscode-themes"]',
        );
        const tokensLoaded = document.querySelector('.vscode-tokens-styles');
        const tokenStyles = document.querySelector('.vscode-tokens-styles').innerText;

        // Everything we need is ready, so initialise
        if (isUsingVt220 && tokensLoaded && tokenStyles) {
          initVT220(observer);
        }
      }
    }
  };

  // This will init the additional canvas effects using WebGL
  const initWebGl = () => {
    retroCanvas = document.getElementById('retro-canvas');
    gl = retroCanvas.getContext('webgl');

    //gl = canvas.getContext( "webgl2" );
    if (!gl) return;

    var texCX = 128;
    var texCY = 128;
    var texPlan = [];
    for (ix = 0; ix < texCX; ++ix) {
      for (iy = 0; iy < texCY; ++iy) {
        var val_x = Math.sin((Math.PI * 6.0 * ix) / texCX);
        var val_y = Math.sin((Math.PI * 6.0 * iy) / texCY);
        texPlan.push(128 + 127 * val_x, 63, 128 + 127 * val_y, 255);
      }
    }

    textureObj = LoadTexture2D(
      'https://raw.githubusercontent.com/Rabbid76/graphics-snippets/master/resource/texture/supermario.jpg',
    );

    progDraw = CreateProg([
      { source: 'draw-shader-vs', stage: gl.VERTEX_SHADER },
      { source: 'draw-shader-fs', stage: gl.FRAGMENT_SHADER },
    ]);
    progDraw.inPos = gl.getAttribLocation(progDraw.progObj, 'inPos');
    if (progDraw.progObj == 0) return;

    bufRect = createVertexBuffer(
      [{ data: [-1, -1, 1, -1, 1, 1, -1, 1], attrSize: 2, attrLoc: progDraw.inPos }],
      [0, 1, 2, 0, 2, 3],
    );

    window.onresize = resize;
    resize();
    requestAnimationFrame(render);
  };

  // try to initialise the theme
  initVT220();

  // Use a mutation observer to check when we can bootstrap the theme
  const observer = new MutationObserver(watchForBootstrap);
  observer.observe(bodyNode, { attributes: true });
})();

const loadShaderTags = () => {
  const shaderVsTag = document.createElement('script');
  shaderVsTag.setAttribute('id', 'draw-shader-vs');
  shaderVsTag.setAttribute('type', 'x-shader/x-vertex');
  shaderVsTag.setAttribute(
    'src',
    'https://raw.githubusercontent.com/TheOld/legacy-term/master/src/js/draw_shader_fs.js',
  );
  document.body.appendChild(shaderVsTag);

  const shaderFsTag = document.createElement('script');
  shaderFsTag.setAttribute('id', 'draw-shader-fs');
  shaderFsTag.setAttribute('type', 'x-shader/x-fragment');
  shaderFsTag.setAttribute(
    'src',
    'https://raw.githubusercontent.com/TheOld/legacy-term/master/src/js/draw_shader_vs.js',
  );
  document.body.appendChild(shaderFsTag);
};
